# Based on https://gist.github.com/joegasper/93ff8ae44fa8712747d85aa92c2b4c78
# allows an additional level of ips
# Get-PingSweep -SubNet '10.1'
# Get-PingSweep -SubNet '10.24'
function ResolveIp($IpAddress) {
    try {
        (Resolve-DnsName $IpAddress -QuickTimeout -ErrorAction SilentlyContinue).NameHost
    } catch {
        $null
    }
}

function Get-OpenPorts {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true)]
        [string]$ipaddr
    )

    $range = 80, 8080, 443, 8081
    foreach ($r in $range) {
        Test-Port -IPAddress $ipaddr -Port $r
    }
}

function Test-Port {
    param (
        [string]$IPAddress,
        [int]$Port,
        [int]$TimeoutInSeconds = 1  # Adjust timeout as needed
    )
    $tcpClient = New-Object System.Net.Sockets.TcpClient
    $connection = $tcpClient.BeginConnect($IPAddress, $Port, $null, $null)
    # Wait for the specified timeout
    $waitHandle = $connection.AsyncWaitHandle
    $holdme = $waitHandle.WaitOne($TimeoutInSeconds * 1000, $false)
    if ($tcpClient.Connected) {
        $tcpClient.EndConnect($connection) | Out-Null
        Write-Output "$IPAddress port $Port is open"
    } else {
       #Write-Output "$IPAddress port $Port is closed or filtered"
    }

    $tcpClient.Close()
}

function Get-PingSweep {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)]
        [string]$SubNet,
        [switch]$ResolveName
    )
    $ips = @()
    switch ($SubNet.Split('.').Count) {
        1 {
            for ($a = 0; $a -le 255; $a++) {
                for ($b = 0; $b -le 255; $b++) {
                    for ($c = 0; $c -le 255; $c++) {
                        $ips += "$SubNet.$a.$b.$c"
                    }
                }
            }
        }
        2 {
            for ($b = 0; $b -le 255; $b++) {
                for ($c = 0; $c -le 255; $c++) {
                    $ips += "$SubNet.$b.$c"
                }
            }
        }
        3 {
            for ($c = 0; $c -le 255; $c++) {
                $ips += "$SubNet.$c"
            }
        }
        4 {
            $ips += $SubNet
        }
        default {
            throw "Invalid subnet format"
        }
    }
    
    $ps = foreach ($ip in $ips)
    { 
            (New-Object Net.NetworkInformation.Ping).SendPingAsync($ip, 250)
    }

    [Threading.Tasks.Task]::WaitAll($ps)
    $ps.Result | Where-Object -FilterScript {$_.Status -eq 'Success' -and $_.Address -like "$subnet*"} |
    Select-Object Address,Status,RoundtripTime -Unique |
    ForEach-Object {
        if ($_.Status -eq 'Success') {
            if (!$ResolveName) {
                $_
            } else {
                if ($_.Address) {
                    $_ | Select-Object Address, @{Expression={ResolveIp($_.Address)};Label='Name'}, Status, RoundtripTime
                } else {
                    $_
                }
            }
            Get-OpenPorts($_.Address)
        }
    }
}
